# MCP Browser Agent

A React-based AI agent system that implements the Model Context Protocol (MCP) architecture entirely within the browser. This system demonstrates how to run MCP Host ‚Üî Client ‚Üî Server components in a browser environment while maintaining protocol compliance with the MCP specification (2025-06-18).

## üèóÔ∏è Architecture Overview

This project implements a complete MCP Host ‚Üî Client ‚Üî Server architecture running in the browser. The system uses in-memory JSON-RPC communication between MCP components, allowing for MCP protocol compliance without requiring separate processes.

### Key Characteristics

- **Browser-Native MCP**: Implements MCP protocol components within a single browser environment
- **Protocol Compliance**: Follows the official MCP specification (2025-06-18) for component interactions
- **In-Memory Transport**: Uses optimized JSON-RPC communication between MCP components
- **Multi-Agent Support**: Supports multiple AI agents sharing MCP infrastructure
- **Tool Management**: Comprehensive tool registration and execution system

## üöÄ Quick Start

### Prerequisites

- **Node.js 18+** 
- **OpenAI API key** (required for AI functionality)

### Setup & Installation

1. **Clone and navigate to the project**:
   ```bash
   git clone <repository-url>
   cd mcp-browser-agent
   ```

2. **Install dependencies**:
   ```bash
   # Install backend dependencies
   cd backend
   npm install
   
   # Install frontend dependencies  
   cd ../frontend
   npm install
   cd ..
   ```

3. **Configure environment**:
   ```bash
   # Copy environment template
   cp backend/.env.example backend/.env
   
   # Edit backend/.env and add your OpenAI API key:
   # OPENAI_API_KEY=your_openai_api_key_here
   # PORT=3001
   ```

4. **Start the application**:
   ```bash
   # Terminal 1: Start backend server
   cd backend
   npm run dev
   
   # Terminal 2: Start frontend (in a new terminal)
   cd frontend  
   npm run dev
   ```

5. **Open your browser**: Navigate to **http://localhost:3000**

That's it! The MCP system is ready. Click "Start Agent" to begin interacting with the AI assistant.

## üèóÔ∏è MCP Architecture Implementation

### Complete MCP Specification Compliance

This implementation follows the **official MCP specification (2025-06-18)** exactly, implementing the required Host ‚Üî Client ‚Üî Server architecture with proper JSON-RPC communication.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    MCP HOST                                 ‚îÇ
‚îÇ              ApplicationHost.ts + MCPHost.ts               ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  ‚Ä¢ Creates and manages MCP client instances                ‚îÇ
‚îÇ  ‚Ä¢ Controls connection permissions and lifecycle           ‚îÇ
‚îÇ  ‚Ä¢ Enforces security policies and user consent             ‚îÇ
‚îÇ  ‚Ä¢ Handles user authorization decisions                    ‚îÇ
‚îÇ  ‚Ä¢ Coordinates AI/LLM integration and sampling             ‚îÇ
‚îÇ  ‚Ä¢ Manages context aggregation across clients              ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ     MCP CLIENT      ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ     MCP SERVER          ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   MCPClient.ts      ‚îÇ    ‚îÇ   MCPServer.ts          ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ                     ‚îÇ    ‚îÇ                         ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Maintains        ‚îÇ    ‚îÇ  ‚Ä¢ Exposes tools via    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ    stateful session ‚îÇ    ‚îÇ    MCP primitives       ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Protocol         ‚îÇ    ‚îÇ  ‚Ä¢ Handles JSON-RPC     ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ    negotiation      ‚îÇ    ‚îÇ    requests             ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Message routing  ‚îÇ    ‚îÇ  ‚Ä¢ Capability           ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Subscriptions    ‚îÇ    ‚îÇ    negotiation          ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Security         ‚îÇ    ‚îÇ  ‚Ä¢ Security boundaries ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ    boundaries       ‚îÇ    ‚îÇ  ‚Ä¢ Tool execution       ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ              ‚îÇ                           ‚îÇ                 ‚îÇ
‚îÇ              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                 ‚îÇ
‚îÇ                        ‚îÇ                                   ‚îÇ
‚îÇ                ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                         ‚îÇ
‚îÇ                ‚îÇ JSON-RPC TRANSPORT                        ‚îÇ
‚îÇ                ‚îÇ MCPTransport.ts ‚îÇ                         ‚îÇ
‚îÇ                ‚îÇ                 ‚îÇ                         ‚îÇ
‚îÇ                ‚îÇ ‚Ä¢ Request/Response correlation            ‚îÇ
‚îÇ                ‚îÇ ‚Ä¢ Serialization/Deserialization          ‚îÇ
‚îÇ                ‚îÇ ‚Ä¢ Error handling                          ‚îÇ
‚îÇ                ‚îÇ ‚Ä¢ Message routing                         ‚îÇ
‚îÇ                ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    Browser Process
```

### MCP Component Mapping

According to the [official MCP specification](https://modelcontextprotocol.io/specification/2025-06-18/architecture), MCP follows a **Host ‚Üî Client ‚Üî Server** architecture. Here's how our browser implementation maps perfectly to these roles:

#### **MCP Host** (`ApplicationHost.ts` + `MCPHost.ts`)
**Official Role**: Container and coordinator for the entire MCP ecosystem

**Our Implementation**:
- **ApplicationHost**: Application-level orchestration, conversation management, LLM integration
- **MCPHost**: Pure MCP protocol coordination, multi-client management, context aggregation
- **Responsibilities**:
  - Creates and manages multiple MCP client instances
  - Controls client connection permissions and lifecycle  
  - Enforces security policies and user consent requirements
  - Handles user authorization decisions
  - Coordinates AI/LLM integration and sampling requests
  - Manages context aggregation across all connected servers

#### **MCP Client** (`MCPClient.ts`)
**Official Role**: Protocol client maintaining 1:1 connection with MCP server

**Our Implementation**:
- Establishes stateful session with the MCP server using JSON-RPC
- Handles protocol negotiation and capability exchange
- Routes protocol messages bidirectionally with proper correlation
- Manages subscriptions and notifications (future feature)
- Maintains security boundaries between servers
- Provides health monitoring and connection management

#### **MCP Server** (`MCPServer.ts`)
**Official Role**: Provides specialized context and capabilities

**Our Implementation**:
- Exposes resources, tools, and prompts via MCP primitives
- Operates independently with focused responsibilities
- Handles JSON-RPC requests with proper error handling
- Manages capability negotiation during initialization
- Maintains proper security constraints and validation
- Provides comprehensive health monitoring and statistics

### JSON-RPC Protocol Implementation

The system implements **true JSON-RPC 2.0 communication** between MCP components:

#### **Protocol Initialization**
```typescript
// JSON-RPC initialization request
const initRequest: InitializeRequest = {
  protocolVersion: "2025-06-18",
  capabilities: {
    tools: { listChanged: true },
    resources: { subscribe: true, listChanged: true },
    sampling: {}
  },
  clientInfo: {
    name: "mcp-browser-client",
    version: "1.0.0"
  }
};

const response = await transport.sendRequest(MCPMethods.INITIALIZE, initRequest);
```

#### **Tool Discovery**
```typescript
// JSON-RPC tools list request
const toolsResponse = await transport.sendRequest(MCPMethods.TOOLS_LIST);

// Convert MCP tools to OpenAI function format
const tools = toolsResponse.tools.map(tool => ({
  type: "function",
  function: {
    name: tool.name,
    description: tool.description,
    parameters: tool.inputSchema
  }
}));
```

#### **Tool Execution**
```typescript
// JSON-RPC tool call request
const mcpResult = await transport.sendRequest(MCPMethods.TOOLS_CALL, {
  name: toolCall.function.name,
  arguments: arguments_
});

// MCP response format
interface ToolCallResponse {
  content: Array<{
    type: string;
    text?: string;
    data?: any;
  }>;
  isError?: boolean;
}
```

### MCP Design Principles Compliance

Our implementation adheres to all four core MCP design principles:

#### 1. **Servers are extremely easy to build** ‚úÖ
```typescript
// Simple tool registration
const calculatorTool = createTool(
  'calculator',
  'Calculate mathematical expressions safely',
  schema,
  async (args) => {
    return { success: true, data: { result: evaluate(args.expression) } };
  }
);

mcpServer.registerTool(calculatorTool);
```

#### 2. **Servers are highly composable** ‚úÖ
- Each tool operates independently with focused functionality
- Multiple tools combine seamlessly through shared protocol
- Modular design supports dynamic tool addition/removal
- Shared MCP infrastructure enables interoperability

#### 3. **Servers cannot read whole conversation** ‚úÖ
- Server receives only tool execution requests via JSON-RPC
- Full conversation history stays with the Host/Client
- Each tool call is isolated with minimal context
- Cross-tool interactions controlled by the Host

#### 4. **Progressive feature addition** ‚úÖ
- Core protocol provides minimal required functionality
- Additional capabilities negotiated during initialization
- Tools can be added/removed dynamically at runtime
- Backwards compatibility maintained through capability negotiation

## üîÑ Detailed Process Flows

### Agent Startup Process Flow

When a user clicks "Start Agent", here's the complete initialization sequence:

#### **Step-by-Step Agent Initialization**

```
üöÄ User Action: Click "Start Agent"
‚îÇ
‚îú‚îÄ‚îÄ 1. UI Component (MCPHostInterface.tsx)
‚îÇ   ‚îú‚îÄ‚îÄ Button click handler triggered
‚îÇ   ‚îú‚îÄ‚îÄ Set loading state: "Starting agent..."
‚îÇ   ‚îî‚îÄ‚îÄ Call: agentManager.createAgent()
‚îÇ
‚îú‚îÄ‚îÄ 2. Agent Manager (MultiAgentManager.ts)
‚îÇ   ‚îú‚îÄ‚îÄ Generate unique agent ID
‚îÇ   ‚îú‚îÄ‚îÄ Create new ApplicationHost instance
‚îÇ   ‚îú‚îÄ‚îÄ Store agent in registry
‚îÇ   ‚îî‚îÄ‚îÄ Call: applicationHost.initialize()
‚îÇ
‚îú‚îÄ‚îÄ 3. Application Host (ApplicationHost.ts)
‚îÇ   ‚îú‚îÄ‚îÄ Set startTime = Date.now()
‚îÇ   ‚îú‚îÄ‚îÄ Log: "üöÄ Starting MCP Browser Agent Application..."
‚îÇ   ‚îú‚îÄ‚îÄ Call: initializeMCPInfrastructure()
‚îÇ   ‚îú‚îÄ‚îÄ Call: initializeConversation()
‚îÇ   ‚îú‚îÄ‚îÄ Set isActive = true
‚îÇ   ‚îî‚îÄ‚îÄ Call: logSystemSummary()
‚îÇ
‚îú‚îÄ‚îÄ 4. MCP Infrastructure Setup (ApplicationHost.initializeMCPInfrastructure)
‚îÇ   ‚îú‚îÄ‚îÄ Get MCP server instance: getMCPServer()
‚îÇ   ‚îú‚îÄ‚îÄ Call: mcpServer.initialize()
‚îÇ   ‚îú‚îÄ‚îÄ Create server config with capabilities
‚îÇ   ‚îú‚îÄ‚îÄ Call: mcpHost.addServer(serverConfig)
‚îÇ   ‚îî‚îÄ‚îÄ Log: "‚úÖ MCP infrastructure initialized"
‚îÇ
‚îú‚îÄ‚îÄ 5. MCP Server Initialization (MCPServer.initialize)
‚îÇ   ‚îú‚îÄ‚îÄ Register all enhanced tools from ServerTools.ts
‚îÇ   ‚îú‚îÄ‚îÄ Setup dynamic list_tools implementation
‚îÇ   ‚îú‚îÄ‚îÄ Initialize JSON-RPC transport handler
‚îÇ   ‚îú‚îÄ‚îÄ Set initialized = true
‚îÇ   ‚îî‚îÄ‚îÄ Log: "‚úÖ Enhanced MCP Server initialized with X tools"
‚îÇ
‚îú‚îÄ‚îÄ 6. MCP Host Server Addition (MCPHost.addServer)
‚îÇ   ‚îú‚îÄ‚îÄ Generate unique client ID
‚îÇ   ‚îú‚îÄ‚îÄ Create new MCPClient instance
‚îÇ   ‚îú‚îÄ‚îÄ Call: client.initialize() [JSON-RPC INITIALIZE]
‚îÇ   ‚îú‚îÄ‚îÄ Store client and config in maps
‚îÇ   ‚îî‚îÄ‚îÄ Log: "‚úÖ Server connected with client ID: xxx"
‚îÇ
‚îú‚îÄ‚îÄ 7. MCP Client Initialization (MCPClient.initialize)
‚îÇ   ‚îú‚îÄ‚îÄ Get MCP transport instance
‚îÇ   ‚îú‚îÄ‚îÄ Build initialize request with protocol version "2025-06-18"
‚îÇ   ‚îú‚îÄ‚îÄ Send JSON-RPC: transport.sendRequest(INITIALIZE, request)
‚îÇ   ‚îú‚îÄ‚îÄ Receive server capabilities
‚îÇ   ‚îú‚îÄ‚îÄ Set connected = true, healthy = true
‚îÇ   ‚îî‚îÄ‚îÄ Log: "‚úÖ Connected to server with capabilities"
‚îÇ
‚îú‚îÄ‚îÄ 8. Conversation Setup (ApplicationHost.initializeConversation)
‚îÇ   ‚îú‚îÄ‚îÄ Get MCP context: mcpHost.getMCPContext()
‚îÇ   ‚îú‚îÄ‚îÄ Build system prompt with tool information
‚îÇ   ‚îú‚îÄ‚îÄ Call: conversationManager.addSystemMessage(prompt)
‚îÇ   ‚îî‚îÄ‚îÄ Log: "‚úÖ Conversation initialized with system prompt"
‚îÇ
‚îú‚îÄ‚îÄ 9. System Summary (ApplicationHost.logSystemSummary)
‚îÇ   ‚îú‚îÄ‚îÄ Get application stats
‚îÇ   ‚îú‚îÄ‚îÄ Perform health check
‚îÇ   ‚îú‚îÄ‚îÄ Log server count, tool availability, LLM status
‚îÇ   ‚îî‚îÄ‚îÄ Log runtime and overall status
‚îÇ
‚îî‚îÄ‚îÄ 10. UI Update
    ‚îú‚îÄ‚îÄ Set loading state: false
    ‚îú‚îÄ‚îÄ Display: "Agent Started Successfully"
    ‚îú‚îÄ‚îÄ Enable chat input
    ‚îî‚îÄ‚îÄ Show agent status: "Ready"

‚è±Ô∏è Total Initialization Time: ~100-200ms
‚úÖ Agent Ready for User Interaction
```

### User Message Processing Flow

When a user sends a message, here's the complete processing sequence:

#### **Scenario 1: Simple Query (No Tools Required)**

**User Input**: *"Hello, how are you?"*

```
üí¨ User Action: Send Message
‚îÇ
‚îú‚îÄ‚îÄ 1. UI Message Submission
‚îÇ   ‚îú‚îÄ‚îÄ User types in chat input
‚îÇ   ‚îú‚îÄ‚îÄ Press Enter or click Send
‚îÇ   ‚îú‚îÄ‚îÄ Disable input, show "Agent is thinking..."
‚îÇ   ‚îî‚îÄ‚îÄ Call: agentManager.processMessage(agentId, message)
‚îÇ
‚îú‚îÄ‚îÄ 2. Agent Manager Routing
‚îÇ   ‚îú‚îÄ‚îÄ Find agent by ID in registry
‚îÇ   ‚îú‚îÄ‚îÄ Validate agent is active
‚îÇ   ‚îî‚îÄ‚îÄ Call: applicationHost.processMessage(message)
‚îÇ
‚îú‚îÄ‚îÄ 3. Application Host Processing
‚îÇ   ‚îú‚îÄ‚îÄ Log: "üë§ User: Hello, how are you?"
‚îÇ   ‚îú‚îÄ‚îÄ Call: conversationManager.addUserMessage(message)
‚îÇ   ‚îú‚îÄ‚îÄ Call: mcpHost.getMCPContext()
‚îÇ   ‚îú‚îÄ‚îÄ Call: getApplicationContext()
‚îÇ   ‚îú‚îÄ‚îÄ Call: mergeContexts(mcpContext, appContext)
‚îÇ   ‚îî‚îÄ‚îÄ Call: getLLMResponse(fullContext)
‚îÇ
‚îú‚îÄ‚îÄ 4. MCP Context Aggregation
‚îÇ   ‚îú‚îÄ‚îÄ Iterate through all connected clients
‚îÇ   ‚îú‚îÄ‚îÄ Call: client.listTools() for each client
‚îÇ   ‚îú‚îÄ‚îÄ JSON-RPC: TOOLS_LIST ‚Üí Server ‚Üí Response
‚îÇ   ‚îú‚îÄ‚îÄ Aggregate all tools: [calculator, dom_query, browser_storage, list_tools]
‚îÇ   ‚îú‚îÄ‚îÄ Collect server capabilities and status
‚îÇ   ‚îî‚îÄ‚îÄ Return: MCPContext with 4 available tools
‚îÇ
‚îú‚îÄ‚îÄ 5. LLM Request Preparation
‚îÇ   ‚îú‚îÄ‚îÄ Get conversation messages for LLM
‚îÇ   ‚îú‚îÄ‚îÄ Convert MCP tools to OpenAI function format
‚îÇ   ‚îú‚îÄ‚îÄ Build request payload with tools array
‚îÇ   ‚îú‚îÄ‚îÄ Log: "üîß DEBUG: Available tools from MCP context: 4"
‚îÇ   ‚îî‚îÄ‚îÄ Call: llmClient.getResponse(messages, {tools})
‚îÇ
‚îú‚îÄ‚îÄ 6. LLM Client Processing
‚îÇ   ‚îú‚îÄ‚îÄ Validate configuration and messages
‚îÇ   ‚îú‚îÄ‚îÄ Add debug event: LLM request started
‚îÇ   ‚îú‚îÄ‚îÄ POST /api/llm ‚Üí Backend ‚Üí OpenAI API
‚îÇ   ‚îú‚îÄ‚îÄ Receive response (no tool_calls for greeting)
‚îÇ   ‚îú‚îÄ‚îÄ Add debug event: LLM response received
‚îÇ   ‚îî‚îÄ‚îÄ Return: {content: "Hello! I'm doing well, thank you for asking..."}
‚îÇ
‚îú‚îÄ‚îÄ 7. Response Processing (No Tool Calls)
‚îÇ   ‚îú‚îÄ‚îÄ Check: llmResponse.tool_calls = undefined
‚îÇ   ‚îú‚îÄ‚îÄ Extract content: "Hello! I'm doing well..."
‚îÇ   ‚îú‚îÄ‚îÄ Call: conversationManager.addAssistantMessage(content)
‚îÇ   ‚îú‚îÄ‚îÄ Log: "ü§ñ LLM Response: Hello! I'm doing well..."
‚îÇ   ‚îî‚îÄ‚îÄ Return response to user
‚îÇ
‚îî‚îÄ‚îÄ 8. UI Update
    ‚îú‚îÄ‚îÄ Display assistant response in chat
    ‚îú‚îÄ‚îÄ Re-enable chat input
    ‚îú‚îÄ‚îÄ Update conversation history
    ‚îî‚îÄ‚îÄ Show "Ready" status

‚è±Ô∏è Total Processing Time: ~800-1200ms
‚úÖ Simple conversation completed
```

#### **Scenario 2: Single Tool Call Required**

**User Input**: *"Calculate sqrt(16) + 5"*

```
üí¨ User Action: Send Message
‚îÇ
‚îú‚îÄ‚îÄ 1-5. [Same as Scenario 1: UI ‚Üí Agent Manager ‚Üí App Host ‚Üí MCP Context ‚Üí LLM Prep]
‚îÇ
‚îú‚îÄ‚îÄ 6. LLM Client Processing
‚îÇ   ‚îú‚îÄ‚îÄ POST /api/llm with tools array
‚îÇ   ‚îú‚îÄ‚îÄ OpenAI determines tool call needed
‚îÇ   ‚îî‚îÄ‚îÄ Return: {tool_calls: [{function: {name: "calculator", arguments: '{"expression":"sqrt(16) + 5"}'}}]}
‚îÇ
‚îú‚îÄ‚îÄ 7. Tool Call Processing
‚îÇ   ‚îú‚îÄ‚îÄ Check: llmResponse.tool_calls.length = 1
‚îÇ   ‚îú‚îÄ‚îÄ Call: processToolCalls(llmResponse)
‚îÇ   ‚îú‚îÄ‚îÄ Add assistant message with tool_calls to conversation
‚îÇ   ‚îî‚îÄ‚îÄ Begin tool execution loop
‚îÇ
‚îú‚îÄ‚îÄ 8. Tool Execution Loop
‚îÇ   ‚îú‚îÄ‚îÄ Extract tool call: calculator("sqrt(16) + 5")
‚îÇ   ‚îú‚îÄ‚îÄ Parse arguments: {expression: "sqrt(16) + 5"}
‚îÇ   ‚îú‚îÄ‚îÄ Add debug event: Tool call parsed
‚îÇ   ‚îú‚îÄ‚îÄ Call: mcpHost.executeTool("calculator", args)
‚îÇ   ‚îî‚îÄ‚îÄ Route to appropriate MCP client
‚îÇ
‚îú‚îÄ‚îÄ 9. MCP Tool Execution
‚îÇ   ‚îú‚îÄ‚îÄ MCPHost finds client with calculator tool
‚îÇ   ‚îú‚îÄ‚îÄ Call: client.executeTool("calculator", args)
‚îÇ   ‚îú‚îÄ‚îÄ JSON-RPC: TOOLS_CALL ‚Üí MCPServer
‚îÇ   ‚îú‚îÄ‚îÄ Server: toolRegistry.executeTool("calculator", args)
‚îÇ   ‚îú‚îÄ‚îÄ Tool execution: SafeMathEvaluator.evaluate("sqrt(16) + 5")
‚îÇ   ‚îú‚îÄ‚îÄ Result: {success: true, data: {result: 9}}
‚îÇ   ‚îú‚îÄ‚îÄ JSON-RPC response: {content: [{type: "text", data: {result: 9}}]}
‚îÇ   ‚îî‚îÄ‚îÄ Return MCP-compliant response
‚îÇ
‚îú‚îÄ‚îÄ 10. Tool Result Processing
‚îÇ   ‚îú‚îÄ‚îÄ Extract result: "9"
‚îÇ   ‚îú‚îÄ‚îÄ Add debug event: Tool result received
‚îÇ   ‚îú‚îÄ‚îÄ Call: conversationManager.addToolResult(toolCallId, "calculator", "9")
‚îÇ   ‚îú‚îÄ‚îÄ Log: "‚úÖ Tool execution successful: calculator"
‚îÇ   ‚îî‚îÄ‚îÄ Conversation now includes tool result
‚îÇ
‚îú‚îÄ‚îÄ 11. Final LLM Response
‚îÇ   ‚îú‚îÄ‚îÄ Send updated conversation (with tool result) to LLM
‚îÇ   ‚îú‚îÄ‚îÄ LLM generates natural language response
‚îÇ   ‚îú‚îÄ‚îÄ Response: "The calculation sqrt(16) + 5 equals 9..."
‚îÇ   ‚îú‚îÄ‚îÄ No additional tool_calls needed
‚îÇ   ‚îî‚îÄ‚îÄ Return final response
‚îÇ
‚îî‚îÄ‚îÄ 12. UI Update
    ‚îú‚îÄ‚îÄ Display: "The calculation sqrt(16) + 5 equals 9..."
    ‚îú‚îÄ‚îÄ Show tool execution in activity log
    ‚îú‚îÄ‚îÄ Update debug panel with JSON-RPC details
    ‚îî‚îÄ‚îÄ Re-enable input

‚è±Ô∏è Total Processing Time: ~1200-1800ms
‚úÖ Single tool call completed successfully
```

#### **Scenario 3: Complex Multi-Step Process**

**User Input**: *"Find the login button and click it"*

```
üí¨ User Action: Send Message
‚îÇ
‚îú‚îÄ‚îÄ 1-6. [Same initial flow as previous scenarios]
‚îÇ
‚îú‚îÄ‚îÄ 7. First Tool Call - Page Analysis
‚îÇ   ‚îú‚îÄ‚îÄ LLM decides: Need to analyze page first
‚îÇ   ‚îú‚îÄ‚îÄ Tool call: dom_query({action: "get_page_info"})
‚îÇ   ‚îú‚îÄ‚îÄ JSON-RPC execution ‚Üí DOM analysis
‚îÇ   ‚îú‚îÄ‚îÄ Result: "Found buttons: ['Sign In', 'Register', 'Forgot Password']"
‚îÇ   ‚îú‚îÄ‚îÄ Add tool result to conversation
‚îÇ   ‚îî‚îÄ‚îÄ Continue to next LLM call
‚îÇ
‚îú‚îÄ‚îÄ 8. Agent Analysis & Decision
‚îÇ   ‚îú‚îÄ‚îÄ Send conversation (with tool result) to LLM
‚îÇ   ‚îú‚îÄ‚îÄ LLM analyzes: "No 'Login' button, but 'Sign In' likely matches"
‚îÇ   ‚îú‚îÄ‚îÄ LLM decides: Try clicking 'Sign In' button
‚îÇ   ‚îî‚îÄ‚îÄ Return: {tool_calls: [{function: {name: "dom_query", arguments: '{"textContent":"Sign In","action":"click"}'}}]}
‚îÇ
‚îú‚îÄ‚îÄ 9. Second Tool Call - Button Click
‚îÇ   ‚îú‚îÄ‚îÄ Tool call: dom_query({textContent: "Sign In", action: "click"})
‚îÇ   ‚îú‚îÄ‚îÄ JSON-RPC execution ‚Üí DOM interaction
‚îÇ   ‚îú‚îÄ‚îÄ Result: "Button clicked successfully"
‚îÇ   ‚îú‚îÄ‚îÄ Add tool result to conversation
‚îÇ   ‚îî‚îÄ‚îÄ Continue to final LLM call
‚îÇ
‚îú‚îÄ‚îÄ 10. Final Response Generation
‚îÇ   ‚îú‚îÄ‚îÄ Send complete conversation to LLM
‚îÇ   ‚îú‚îÄ‚îÄ LLM analyzes all tool results
‚îÇ   ‚îú‚îÄ‚îÄ No additional tools needed
‚îÇ   ‚îî‚îÄ‚îÄ Generate: "I found and clicked the login button (labeled 'Sign In')..."
‚îÇ
‚îî‚îÄ‚îÄ 11. UI Update
    ‚îú‚îÄ‚îÄ Display final response
    ‚îú‚îÄ‚îÄ Show both tool executions in activity log
    ‚îú‚îÄ‚îÄ Debug panel shows complete JSON-RPC sequence
    ‚îî‚îÄ‚îÄ Conversation complete

‚è±Ô∏è Total Processing Time: ~2000-3000ms
üîÑ Multi-step process: 2 tool calls + final response
‚úÖ Complex task completed with adaptation
```

### Error Handling Process Flow

#### **Scenario: Tool Execution Failure**

**User Input**: *"Click the 'NonExistent' button"*

```
üí¨ Error Handling Flow
‚îÇ
‚îú‚îÄ‚îÄ 1-7. [Normal flow until tool execution]
‚îÇ
‚îú‚îÄ‚îÄ 8. Tool Execution Failure
‚îÇ   ‚îú‚îÄ‚îÄ Tool call: dom_query({textContent: "NonExistent", action: "click"})
‚îÇ   ‚îú‚îÄ‚îÄ DOM search finds no matching elements
‚îÇ   ‚îú‚îÄ‚îÄ Tool returns: {success: false, error: "No elements found"}
‚îÇ   ‚îú‚îÄ‚îÄ MCP response: {content: [{type: "text", text: "No elements found"}], isError: true}
‚îÇ   ‚îî‚îÄ‚îÄ Add error result to conversation
‚îÇ
‚îú‚îÄ‚îÄ 9. Agent Error Recovery
‚îÇ   ‚îú‚îÄ‚îÄ LLM receives tool error in conversation
‚îÇ   ‚îú‚îÄ‚îÄ LLM analyzes: "Button not found, need to check page"
‚îÇ   ‚îú‚îÄ‚îÄ LLM decides: Use get_page_info to see available options
‚îÇ   ‚îî‚îÄ‚îÄ Generate recovery tool call
‚îÇ
‚îú‚îÄ‚îÄ 10. Recovery Tool Execution
‚îÇ   ‚îú‚îÄ‚îÄ Tool call: dom_query({action: "get_page_info"})
‚îÇ   ‚îú‚îÄ‚îÄ Successful execution returns page elements
‚îÇ   ‚îú‚îÄ‚îÄ Add recovery result to conversation
‚îÇ   ‚îî‚îÄ‚îÄ Continue to final response
‚îÇ
‚îú‚îÄ‚îÄ 11. Adaptive Response
‚îÇ   ‚îú‚îÄ‚îÄ LLM generates helpful response
‚îÇ   ‚îú‚îÄ‚îÄ "I couldn't find a 'NonExistent' button, but I found: [list]"
‚îÇ   ‚îú‚îÄ‚îÄ Suggests alternatives based on actual page content
‚îÇ   ‚îî‚îÄ‚îÄ Graceful error handling completed
‚îÇ
‚îî‚îÄ‚îÄ 12. Debug Information
    ‚îú‚îÄ‚îÄ Error logged in debug panel
    ‚îú‚îÄ‚îÄ Tool execution history shows failure + recovery
    ‚îú‚îÄ‚îÄ Complete error context preserved
    ‚îî‚îÄ‚îÄ User informed of issue and alternatives

‚è±Ô∏è Error Recovery Time: ~1500-2500ms
üîÑ Error ‚Üí Analysis ‚Üí Recovery ‚Üí Response
‚úÖ Graceful error handling with user guidance
```

## üîÑ Complete MCP Execution Flow

### High-Level System Flow

The system follows the official MCP protocol for all tool interactions:

```mermaid
sequenceDiagram
    participant User as User Interface
    participant AppHost as Application Host
    participant MCPHost as MCP Host
    participant MCPClient as MCP Client
    participant Transport as JSON-RPC Transport
    participant MCPServer as MCP Server
    participant LLM as LLM Client
    participant Backend as Backend Proxy
    participant OpenAI as OpenAI API

    User->>AppHost: Send Message
    AppHost->>MCPHost: getMCPContext()
    
    Note over MCPClient,MCPServer: MCP Initialization (if needed)
    MCPHost->>MCPClient: Request context
    MCPClient->>Transport: sendRequest(INITIALIZE)
    Transport->>MCPServer: JSON-RPC INITIALIZE
    MCPServer-->>Transport: Capabilities response
    Transport-->>MCPClient: Server capabilities
    MCPClient-->>MCPHost: Connection established
    
    MCPHost->>MCPClient: listTools()
    MCPClient->>Transport: sendRequest(TOOLS_LIST)
    Transport->>MCPServer: JSON-RPC TOOLS_LIST
    MCPServer-->>Transport: Available tools
    Transport-->>MCPClient: Tools array
    MCPClient-->>MCPHost: MCP tools
    MCPHost-->>AppHost: MCP context with tools
    
    AppHost->>LLM: getResponse(messages, tools)
    LLM->>Backend: POST /api/llm
    Backend->>OpenAI: Chat Completions API
    OpenAI-->>Backend: Response with tool_calls
    Backend-->>LLM: Structured response
    LLM-->>AppHost: Parsed response with tool calls
    
    alt Tool calls detected
        loop For each tool call
            AppHost->>MCPHost: executeTool(name, args)
            MCPHost->>MCPClient: executeTool(name, args)
            MCPClient->>Transport: sendRequest(TOOLS_CALL)
            Transport->>MCPServer: JSON-RPC TOOLS_CALL
            MCPServer->>MCPServer: Execute via ToolRegistry
            MCPServer-->>Transport: MCP tool result
            Transport-->>MCPClient: Tool response
            MCPClient-->>MCPHost: Tool result
            MCPHost-->>AppHost: Formatted result
            AppHost->>AppHost: Add to conversation
        end
        
        AppHost->>LLM: getResponse() for final answer
        LLM->>Backend: POST /api/llm
        Backend->>OpenAI: Chat Completions API
        OpenAI-->>Backend: Final response
        Backend-->>LLM: Final answer
        LLM-->>AppHost: Final response
    end
    
    AppHost-->>User: Display response
```

### Detailed Message Processing

When a user sends a message, the system follows this precise MCP-compliant flow:

#### 1. **Context Aggregation** (`MCPHost.getMCPContext()`)
```typescript
async getMCPContext(): Promise<MCPContext> {
  const allTools: MCPTool[] = [];
  const serverCapabilities: MCPCapabilities[] = [];
  const serverStatus: ServerStatus[] = [];

  // Aggregate from all connected MCP servers
  for (const [clientId, client] of this.clients.entries()) {
    const tools = await client.listTools(); // JSON-RPC TOOLS_LIST
    allTools.push(...tools);
    
    const capabilities = client.getServerCapabilities();
    serverCapabilities.push(capabilities);
  }

  return {
    availableTools: allTools,
    serverCapabilities,
    serverStatus,
    aggregatedCapabilities: this.aggregateCapabilities(serverCapabilities)
  };
}
```

#### 2. **Tool Discovery via JSON-RPC** (`MCPClient.listTools()`)
```typescript
async listTools(): Promise<MCPTool[]> {
  const transport = getMCPTransport();
  const response: ToolsListResponse = await transport.sendRequest(MCPMethods.TOOLS_LIST);
  return response.tools;
}
```

#### 3. **LLM Integration** (OpenAI Chat Completions API)
```typescript
const tools = mcpContext.availableTools.map(tool => ({
  type: "function" as const,
  function: {
    name: tool.name,
    description: tool.description,
    parameters: tool.inputSchema
  }
}));

const llmResponse = await this.llmClient.getResponse(messages, { tools });
```

#### 4. **Tool Execution via JSON-RPC** (`MCPClient.executeTool()`)
```typescript
async executeTool(toolName: string, args: any): Promise<ToolCallResponse> {
  const transport = getMCPTransport();
  const request: ToolCallRequest = {
    name: toolName,
    arguments: args
  };

  const response: ToolCallResponse = await transport.sendRequest(
    MCPMethods.TOOLS_CALL, 
    request
  );

  return response; // MCP-compliant response format
}
```

#### 5. **Server-Side Tool Execution** (`MCPServer.handleToolsCall()`)
```typescript
private async handleToolsCall(request: JsonRpcRequest): Promise<JsonRpcResponse> {
  const params = request.params as ToolCallRequest;
  
  const result = await this.callTool(params.name, params.arguments);
  
  return {
    jsonrpc: "2.0",
    id: request.id,
    result: result // ToolCallResponse format
  };
}
```

## üèõÔ∏è Detailed Architecture & Components

### üìÅ **Project Structure**

```
mcp-browser-agent/
‚îú‚îÄ‚îÄ backend/                    # Express.js API server
‚îÇ   ‚îú‚îÄ‚îÄ index.js               # OpenAI API proxy server
‚îÇ   ‚îú‚îÄ‚îÄ package.json           # Backend dependencies
‚îÇ   ‚îî‚îÄ‚îÄ .env.example           # Environment template
‚îú‚îÄ‚îÄ frontend/                  # React MCP application
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app/               # üè† Application Layer
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ApplicationHost.ts     # Main application orchestrator
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConversationManager.ts # Chat history management
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HostConfiguration.ts   # Centralized configuration
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MultiAgentManager.ts   # Multi-agent coordination
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mcp-core/          # üîå MCP Protocol Implementation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MCPHost.ts             # MCP host coordinator
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MCPClient.ts           # MCP client protocol handler
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MCPServer.ts           # MCP server implementation
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MCPTransport.ts        # JSON-RPC transport layer
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ MCPProtocol.ts         # Protocol definitions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mcp-tools/         # üõ†Ô∏è Tool Management System
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ToolRegistry.ts        # Tool registration & execution
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Tool.ts                # Tool abstraction framework
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ServerTools.ts         # Built-in tool implementations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/        # üé® UI Components
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MCPHostInterface.tsx   # Multi-agent interface
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MCPDebugPanel.tsx      # Debug & monitoring
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TokenUsageDisplay.tsx  # Token usage tracking
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ llm/              # üß† LLM Integration
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LLMClient.ts           # OpenAI API client
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ debug/            # üìä Debug & Monitoring
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DebugEventManager.ts   # Event tracking system
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ App.tsx           # Main application entry
‚îÇ   ‚îú‚îÄ‚îÄ package.json          # Frontend dependencies
‚îÇ   ‚îî‚îÄ‚îÄ vite.config.ts        # Vite configuration
‚îî‚îÄ‚îÄ README.md                 # This file
```

### üîå **MCP Protocol Layer** (`frontend/src/mcp-core/`)

#### **MCPProtocol.ts** - Protocol Definitions & Standards
```typescript
// Official MCP protocol methods (2025-06-18)
export const MCPMethods = {
  INITIALIZE: 'initialize',
  TOOLS_LIST: 'tools/list', 
  TOOLS_CALL: 'tools/call'
} as const;

// JSON-RPC 2.0 message structures
export interface JsonRpcRequest {
  jsonrpc: '2.0';
  id: string | number;
  method: string;
  params?: any;
}

export interface JsonRpcResponse {
  jsonrpc: '2.0';
  id: string | number;
  result?: any;
  error?: JsonRpcError;
}
```

**Core Functionality:**
- Defines official MCP protocol methods and message formats
- Implements JSON-RPC 2.0 specification for MCP communication
- Provides type safety for all MCP protocol interactions
- Ensures compliance with MCP specification version 2025-06-18
- Includes comprehensive error codes and capability definitions

#### **MCPTransport.ts** - JSON-RPC Transport Implementation
```typescript
export class MCPTransport {
  async sendRequest(method: string, params?: any): Promise<any> {
    const request: JsonRpcRequest = {
      jsonrpc: "2.0",
      id: this.generateRequestId(),
      method,
      params
    };

    // Simulate proper JSON-RPC serialization/deserialization
    const serializedRequest = JSON.stringify(request);
    const deserializedRequest = JSON.parse(serializedRequest);

    const response = await this.messageHandler(deserializedRequest);
    
    // Handle JSON-RPC response with proper error checking
    if (response.error) {
      throw new MCPError(response.error.message, response.error.code);
    }

    return response.result;
  }
}
```

**Core Functionality:**
- **In-Memory JSON-RPC**: Simulates network JSON-RPC with full serialization/deserialization
- **Request/Response Correlation**: Unique request IDs for proper message matching
- **Error Handling**: Standard JSON-RPC error codes and MCP-specific errors
- **Performance Optimization**: Zero-latency communication within browser context
- **Debug Integration**: Comprehensive request/response logging for monitoring

#### **MCPHost.ts** - Multi-Client Coordinator
```typescript
export class MCPHost {
  private clients: Map<string, MCPClient> = new Map();
  private serverConfigs: Map<string, ServerConfig> = new Map();

  async addServer(config: ServerConfig): Promise<string> {
    const clientId = this.generateClientId();
    const client = new MCPClient(config.name);
    
    await client.initialize(); // JSON-RPC INITIALIZE
    
    this.clients.set(clientId, client);
    this.serverConfigs.set(clientId, config);
    
    return clientId;
  }

  async getMCPContext(): Promise<MCPContext> {
    const allTools: MCPTool[] = [];
    
    // Aggregate tools from all connected servers
    for (const [clientId, client] of this.clients.entries()) {
      const tools = await client.listTools(); // JSON-RPC TOOLS_LIST
      allTools.push(...tools);
    }

    return {
      availableTools: allTools,
      serverCapabilities: this.getAggregatedCapabilities(),
      serverStatus: await this.getServerStatus(),
      aggregatedCapabilities: this.aggregateCapabilities()
    };
  }
}
```

**Core Functionality:**
- **Multi-Client Management**: Creates and manages multiple MCP client instances
- **Connection Lifecycle**: Handles client connection permissions and lifecycle
- **Context Aggregation**: Merges context from all connected MCP servers
- **Tool Routing**: Routes tool execution requests to appropriate clients
- **Security Enforcement**: Maintains proper isolation between MCP components
- **Health Monitoring**: Continuous monitoring of all server connections

#### **MCPClient.ts** - Protocol Client Implementation
```typescript
export class MCPClient {
  async initialize(): Promise<void> {
    const transport = getMCPTransport();
    
    const initRequest: InitializeRequest = {
      protocolVersion: "2025-06-18",
      capabilities: this.clientCapabilities,
      clientInfo: {
        name: "mcp-browser-client",
        version: "1.0.0"
      }
    };

    const initResponse = await transport.sendRequest(MCPMethods.INITIALIZE, initRequest);
    this.serverCapabilities = initResponse.capabilities;
    this.connected = true;
  }

  async executeTool(toolName: string, args: any): Promise<ToolCallResponse> {
    const transport = getMCPTransport();
    
    const response = await transport.sendRequest(MCPMethods.TOOLS_CALL, {
      name: toolName,
      arguments: args
    });

    return response; // MCP-compliant ToolCallResponse
  }
}
```

**Core Functionality:**
- **Stateful Sessions**: Maintains persistent connection state with MCP server
- **Protocol Negotiation**: Handles capability exchange during initialization
- **Message Routing**: Bidirectional JSON-RPC message routing with correlation
- **Health Management**: Connection health monitoring and recovery
- **Security Boundaries**: Maintains isolation between different servers

#### **MCPServer.ts** - Server Implementation
```typescript
export class MCPServer {
  async handleJsonRpcMessage(request: JsonRpcRequest): Promise<JsonRpcResponse> {
    switch (request.method) {
      case MCPMethods.INITIALIZE:
        return await this.handleInitialize(request);
      case MCPMethods.TOOLS_LIST:
        return await this.handleToolsList(request);
      case MCPMethods.TOOLS_CALL:
        return await this.handleToolsCall(request);
      default:
        return this.createErrorResponse(request.id, MCPErrorCodes.METHOD_NOT_FOUND);
    }
  }

  private async handleToolsCall(request: JsonRpcRequest): Promise<JsonRpcResponse> {
    const params = request.params as ToolCallRequest;
    
    const result = await this.toolRegistry.executeTool(params.name, params.arguments);
    
    const mcpResponse: ToolCallResponse = {
      content: [{
        type: "text",
        text: JSON.stringify(result.data, null, 2),
        data: result.data
      }],
      isError: !result.success
    };

    return {
      jsonrpc: "2.0",
      id: request.id,
      result: mcpResponse
    };
  }
}
```

**Core Functionality:**
- **JSON-RPC Server**: Handles all MCP protocol requests with proper response formatting
- **Tool Management**: Integration with ToolRegistry for tool execution
- **Capability Negotiation**: Proper MCP capability exchange during initialization
- **Error Handling**: Comprehensive error handling with MCP-specific error codes
- **Resource Management**: Manages tools, resources, and server state

### üõ†Ô∏è **Tool Management System** (`frontend/src/mcp-tools/`)

#### **ToolRegistry.ts** - Centralized Tool Management
```typescript
export class ToolRegistry {
  private tools: Map<string, Tool> = new Map();
  private executionHistory: Array<{
    toolName: string;
    parameters: any;
    result: ToolResult;
    timestamp: string;
  }> = [];

  async executeTool(name: string, parameters: any): Promise<ToolResult> {
    const tool = this.tools.get(name);
    
    if (!tool) {
      return {
        success: false,
        error: `Tool '${name}' not found. Available: ${Array.from(this.tools.keys()).join(', ')}`
      };
    }

    const result = await tool.execute(parameters);
    this.recordExecution(name, parameters, result);
    
    return result;
  }

  getExecutionStats(): {
    totalExecutions: number;
    successfulExecutions: number;
    failedExecutions: number;
    toolUsageCounts: Record<string, number>;
    recentErrors: string[];
  } {
    // Comprehensive execution analytics
  }
}
```

**Core Functionality:**
- **Tool Registration**: Dynamic tool registration with validation and conflict detection
- **Execution Engine**: Safe tool execution with comprehensive error handling
- **History Tracking**: Complete execution history with timing and result tracking
- **Statistics**: Detailed execution statistics and performance metrics
- **Search & Discovery**: Tool search by name, description, and capabilities

#### **Tool.ts** - Tool Abstraction Framework
```typescript
export class Tool {
  constructor(
    public readonly name: string,
    public readonly description: string,
    public readonly inputSchema: any,
    private readonly handler: ToolHandler,
    public readonly title?: string
  ) {}

  validate(): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    if (!this.name || typeof this.name !== 'string') {
      errors.push('Tool name must be a non-empty string');
    }
    
    if (!this.description || typeof this.description !== 'string') {
      errors.push('Tool description must be a non-empty string');
    }
    
    // JSON Schema validation for inputSchema
    if (!this.inputSchema || typeof this.inputSchema !== 'object') {
      errors.push('Tool inputSchema must be a valid JSON Schema object');
    }

    return { valid: errors.length === 0, errors };
  }

  async execute(parameters: any): Promise<ToolResult> {
    try {
      // Parameter validation against schema
      const validation = this.validateParameters(parameters);
      if (!validation.valid) {
        return {
          success: false,
          error: `Parameter validation failed: ${validation.errors.join(', ')}`
        };
      }

      const result = await this.handler(parameters);
      
      return {
        success: true,
        data: result,
        metadata: {
          toolName: this.name,
          executedAt: new Date().toISOString(),
          parameters
        }
      };
      
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        metadata: {
          toolName: this.name,
          executedAt: new Date().toISOString(),
          parameters
        }
      };
    }
  }
}
```

**Core Functionality:**
- **Tool Abstraction**: Unified interface for all tool implementations
- **Schema Validation**: JSON Schema validation for tool parameters
- **Error Handling**: Comprehensive error handling with detailed error messages
- **Result Standardization**: Consistent result format across all tools
- **Metadata Management**: Tool metadata, descriptions, and capability information

#### **ServerTools.ts** - Built-in Tool Implementations

**Calculator Tool** - Safe Mathematical Expression Evaluation
```typescript
export const calculatorTool = createTool(
  'calculator',
  'Calculate mathematical expressions safely with support for basic arithmetic, exponents (^), and square root (sqrt)',
  {
    type: 'object',
    properties: {
      expression: {
        type: 'string',
        description: 'Mathematical expression to evaluate (e.g., "2 + 3 * 4", "sqrt(16)", "2^3")'
      }
    },
    required: ['expression']
  },
  async (args) => {
    const evaluator = new SafeMathEvaluator();
    const result = evaluator.evaluate(args.expression);
    return { result, expression: args.expression };
  }
);
```

**DOM Query Tool** - Comprehensive Webpage Interaction
```typescript
export const domQueryTool = createTool(
  'dom_query',
  'Interact with webpage elements: click buttons, fill forms, read content, scroll, and manipulate DOM elements',
  {
    type: 'object',
    properties: {
      action: {
        type: 'string',
        enum: ['click', 'value', 'scroll', 'get_page_info'],
        description: 'Action to perform on the element or page'
      },
      textContent: { type: 'string', description: 'Exact text content to find' },
      partialText: { type: 'string', description: 'Partial text to search for' },
      value: { type: 'string', description: 'Value to set (for input fields)' }
    },
    required: ['action']
  },
  async (args) => {
    // Advanced element finding with multiple fallback strategies
    // Supports clicking, form filling, content reading, scrolling
    // Text-based element location with intelligent matching
  }
);
```

**Browser Storage Tool** - Persistent Data Management
```typescript
export const browserStorageTool = createTool(
  'browser_storage',
  'Manage persistent browser storage: get, set, remove, clear, and list keys',
  {
    type: 'object',
    properties: {
      action: {
        type: 'string',
        enum: ['get', 'set', 'remove', 'clear', 'keys'],
        description: 'Storage action to perform'
      },
      key: { type: 'string', description: 'Storage key' },
      value: { type: 'string', description: 'Value to store' }
    },
    required: ['action']
  },
  async (args) => {
    // localStorage integration with error handling
    // Supports all standard storage operations
    // Automatic JSON serialization/deserialization
  }
);
```

### üè† **Application Layer** (`frontend/src/app/`)

#### **ApplicationHost.ts** - Main Application Orchestrator
```typescript
export class ApplicationHost {
  private mcpHost: MCPHost;
  private llmClient: LLMClient;
  private conversationManager: ConversationManager;

  async processMessage(userMessage: string): Promise<string> {
    // 1. Get MCP context (tools, capabilities, server status)
    const mcpContext = await this.mcpHost.getMCPContext();
    
    // 2. Get application context (conversation, preferences, etc.)
    const appContext = this.getApplicationContext();
    
    // 3. Merge contexts for LLM
    const fullContext = this.mergeContexts(mcpContext, appContext);
    
    // 4. Get LLM response with tools
    const llmResponse = await this.getLLMResponse(fullContext);
    
    // 5. Process tool calls if any
    if (llmResponse.tool_calls?.length > 0) {
      return await this.processToolCalls(llmResponse);
    }
    
    // 6. Return direct response
    return llmResponse.content || 'I understand, but I don\'t have a specific response.';
  }
}
```

**Core Functionality:**
- **Application Orchestration**: Coordinates all application-level concerns
- **MCP Integration**: Seamless integration with MCP infrastructure
- **Conversation Management**: Maintains chat history and context
- **LLM Coordination**: Handles LLM requests with tool integration
- **Error Recovery**: Comprehensive error handling with graceful degradation
- **Multi-Step Processing**: Supports recursive tool calling for complex tasks

#### **ConversationManager.ts** - Chat History Management
```typescript
export class ConversationManager {
  private messages: Message[] = [];
  private maxMessages: number = 20;

  addUserMessage(content: string): void {
    this.messages.push({
      role: 'user',
      content,
      timestamp: Date.now()
    });
    this.trimIfNeeded();
  }

  addToolResult(toolCallId: string, toolName: string, result: string): void {
    this.messages.push({
      role: 'tool',
      tool_call_id: toolCallId,
      name: toolName,
      content: result,
      timestamp: Date.now()
    });
    this.trimIfNeeded();
  }

  getMessagesForLLM(): Omit<Message, 'timestamp'>[] {
    return this.messages.map(({ timestamp, ...message }) => message);
  }
}
```

**Core Functionality:**
- **Message History**: Maintains complete conversation history with timestamps
- **Context Trimming**: Automatic conversation trimming to stay within limits
- **LLM Formatting**: Formats messages for LLM consumption
- **Tool Integration**: Proper handling of tool call results in conversation
- **Statistics**: Comprehensive conversation analytics and metrics

#### **HostConfiguration.ts** - Centralized Configuration
```typescript
export class Configuration {
  get llmConfig(): LLMConfig {
    return {
      model: "gpt-4o-mini",
      temperature: 0.3,
      maxTokens: 1000,
      timeout: 30000
    };
  }
  
  get serverConfig(): ServerConfig {
    return {
      name: "browser-mcp-server",
      version: "1.0.0", 
      protocolVersion: "2025-06-18",
      capabilities: {
        tools: { listChanged: true },
        resources: { subscribe: true, listChanged: true }
      }
    };
  }
}
```

**Core Functionality:**
- **Singleton Pattern**: Ensures consistent configuration across entire application
- **Environment Integration**: Loads from environment variables with fallbacks
- **MCP Compliance**: Proper protocol version and capability configuration
- **Validation**: Comprehensive configuration validation with helpful error messages

## ‚ú® Key Features

### ü§ñ **Multi-Agent Architecture**
- **Independent Agents**: Run up to 5 AI agents simultaneously with complete isolation
- **Shared Infrastructure**: Efficient resource sharing through MCP architecture
- **Individual Controls**: Start, stop, rename, and manage each agent independently
- **Context Isolation**: Each agent maintains separate conversation history and state

### üîß **Advanced Tool System**
- **Safe Calculator**: Secure mathematical expression evaluator with sqrt, exponents, and validation
- **DOM Interaction**: Comprehensive webpage manipulation with intelligent element finding
- **Browser Storage**: Persistent data storage with localStorage integration
- **Dynamic Discovery**: Real-time tool registration and capability detection

### üß† **Sophisticated AI Capabilities**
- **MCP Standard Compliance**: Full OpenAI Chat Completions API compatibility
- **Context Management**: Smart conversation history with automatic trimming
- **Multi-Step Processing**: Recursive tool calling for complex problem solving
- **Error Recovery**: Robust error handling with automatic fallback strategies

### üìä **Comprehensive Monitoring**
- **Real-time Debugging**: Complete request/response monitoring with JSON-RPC details
- **Performance Analytics**: Execution statistics, timing metrics, and error tracking
- **Tool Visibility**: Live tool discovery and schema inspection
- **Health Monitoring**: Continuous system health checks and status reporting

## üîÑ Multi-Step Problem Solving

### Iterative Tool Calling

The MCP Browser Agent excels at **chaining multiple tool calls together** to solve complex, multi-step problems. The system uses a recursive processing pattern that allows it to:

1. **Execute initial tools** based on user request
2. **Analyze tool results** to understand what was accomplished
3. **Determine next steps** needed to complete the task
4. **Execute additional tools** as needed
5. **Repeat until task is complete**

The key capability is that **tools provide results back to the agent**, which can then **analyze those results and decide to use more tools** before providing a final response to the user.

#### Real-World Example: Complex Web Interaction

**User Request**: *"Find the login form, fill it with username 'john' and password 'secret123', then click submit"*

**Agent Execution Flow**:
```
Step 1: üîç Find Login Form
‚îú‚îÄ‚îÄ Tool: dom_query(action="get_page_info")
‚îú‚îÄ‚îÄ Result: "Found login form with username and password fields"
‚îî‚îÄ‚îÄ Agent Decision: "I can see the form, now I need to locate the username field"

Step 2: üìù Fill Username Field  
‚îú‚îÄ‚îÄ Tool: dom_query(partialText="username", action="value", value="john")
‚îú‚îÄ‚îÄ Result: "Username field filled successfully"
‚îî‚îÄ‚îÄ Agent Decision: "Username filled, now I need to find the password field"

Step 3: üîê Fill Password Field
‚îú‚îÄ‚îÄ Tool: dom_query(partialText="password", action="value", value="secret123")  
‚îú‚îÄ‚îÄ Result: "Password field filled successfully"
‚îî‚îÄ‚îÄ Agent Decision: "Both fields filled, now I need to find and click submit"

Step 4: ‚úÖ Submit Form
‚îú‚îÄ‚îÄ Tool: dom_query(partialText="submit", action="click")
‚îú‚îÄ‚îÄ Result: "Submit button clicked successfully"
‚îî‚îÄ‚îÄ Agent Decision: "Task completed successfully"

Final Response: "I've successfully found the login form, filled in the username 'john' and password, then clicked the submit button. The login process is complete."
```

#### Example: Data Analysis with Multiple Tool Calls

**User Request**: *"Calculate the area of a circle with radius 5, then store it and also calculate what percentage that is of a square with side 10"*

**Agent Execution Flow**:
```
Step 1: üßÆ Calculate Circle Area
‚îú‚îÄ‚îÄ Tool: calculator(expression="3.14159 * 5^2")
‚îú‚îÄ‚îÄ Result: {"result": 78.53975}
‚îî‚îÄ‚îÄ Agent Decision: "Got circle area, now I need to store it and calculate square area"

Step 2: üíæ Store Circle Area
‚îú‚îÄ‚îÄ Tool: browser_storage(action="set", key="circle_area", value="78.53975")
‚îú‚îÄ‚îÄ Result: {"success": true}
‚îî‚îÄ‚îÄ Agent Decision: "Stored successfully, now calculate square area"

Step 3: üî≤ Calculate Square Area  
‚îú‚îÄ‚îÄ Tool: calculator(expression="10 * 10")
‚îú‚îÄ‚îÄ Result: {"result": 100}
‚îî‚îÄ‚îÄ Agent Decision: "Got square area, now calculate percentage"

Step 4: üìä Calculate Percentage
‚îú‚îÄ‚îÄ Tool: calculator(expression="78.53975 / 100 * 100")
‚îú‚îÄ‚îÄ Result: {"result": 78.53975}
‚îî‚îÄ‚îÄ Agent Decision: "All calculations complete"

Final Response: "I've calculated the area of a circle with radius 5 as 78.54 square units, stored this value in browser storage, and determined that this represents 78.54% of the area of a square with side 10 (which has an area of 100 square units)."
```

#### Example: Error Recovery and Adaptation

**User Request**: *"Click the 'Login' button"*

**Agent Execution Flow**:
```
Step 1: üéØ Try Direct Text Match
‚îú‚îÄ‚îÄ Tool: dom_query(textContent="Login", action="click")
‚îú‚îÄ‚îÄ Result: "No elements found matching the criteria"
‚îî‚îÄ‚îÄ Agent Decision: "Exact match failed, let me try partial text search"

Step 2: üîç Try Partial Text Match
‚îú‚îÄ‚îÄ Tool: dom_query(partialText="login", action="click")
‚îú‚îÄ‚îÄ Result: "No elements found matching the criteria"  
‚îî‚îÄ‚îÄ Agent Decision: "Text search failed, let me check what's actually on the page"

Step 3: üìã Analyze Page Content
‚îú‚îÄ‚îÄ Tool: dom_query(action="get_page_info")
‚îú‚îÄ‚îÄ Result: "Found buttons: ['Sign In', 'Register', 'Forgot Password']"
‚îî‚îÄ‚îÄ Agent Decision: "I see 'Sign In' which is likely the login button"

Step 4: ‚úÖ Click Correct Button
‚îú‚îÄ‚îÄ Tool: dom_query(textContent="Sign In", action="click")
‚îú‚îÄ‚îÄ Result: "Button clicked successfully"
‚îî‚îÄ‚îÄ Agent Decision: "Successfully found and clicked the login button"

Final Response: "I found and clicked the login button (labeled 'Sign In') after adapting my search strategy when the initial attempts didn't find an exact 'Login' button."
```

### Technical Implementation

The recursive tool calling is implemented through the MCP protocol, where **tool results are added to the conversation context** and the agent can **analyze those results to decide on further actions**:

```typescript
// Process tool calls and add results to conversation
for (const toolCall of llmResponse.tool_calls) {
  const result = await this.mcpHost.executeTool(toolCall.function.name, args);
  
  // Add tool result to conversation context
  this.conversationManager.addToolResult(
    toolCall.id,
    toolCall.function.name,
    resultContent
  );
}

// Agent analyzes all tool results and decides next steps
const finalResponse = await this.llmClient.getResponse(this.context.messages, {
  tools: tools.length > 0 ? tools : undefined
});

// If agent decides more tools are needed based on results, recursively process
if (finalResponse.tool_calls && finalResponse.tool_calls.length > 0) {
  return await this.processToolCalls(finalResponse);
}
```

### Key Benefits of Tool Result Analysis

1. **Adaptive Problem Solving**: Agent can change strategy based on tool results
2. **Error Recovery**: Failed tool calls can trigger alternative approaches  
3. **Context Building**: Each tool result provides information for subsequent decisions
4. **Complex Workflows**: Multi-step processes can be completed automatically
5. **Data Integration**: Results from multiple tools can be combined and analyzed

## üéØ Usage Examples

### Single Agent Mode
1. Click "‚ñ∂Ô∏è Start Agent" to initialize the MCP system
2. Type questions or requests in the chat interface
3. Watch real-time tool execution in the activity log
4. Monitor performance statistics and JSON-RPC communication

### Multi-Agent Mode
1. Click "Switch to Multi-Agent Mode" 
2. Create multiple agents with custom names
3. Switch between agent tabs for independent conversations
4. Start/stop agents individually as needed
5. Each agent maintains separate context and MCP connections

### Example Interactions
- **Math**: "Calculate the square root of 144 plus 5 times 3"
- **Web Interaction**: "Click the login button and fill in the username field"
- **Data Storage**: "Remember that my favorite color is blue"
- **Tool Discovery**: "What tools do you have available?"
- **Complex Tasks**: "Find all buttons on the page, then click the one that says 'Submit'"

## üõ†Ô∏è Development

### Adding Custom Tools

Create new tools using the MCP-compliant tool framework:

```typescript
import { createTool } from './mcp-tools/Tool';

const myCustomTool = createTool(
  'my_tool',
  'Description of what this tool does',
  {
    type: 'object',
    properties: {
      input: { type: 'string', description: 'Input parameter' }
    },
    required: ['input']
  },
  async (args) => {
    // Tool implementation
    return { result: 'success', data: args.input };
  }
);

// Register in mcp-tools/ServerTools.ts
export const enhancedTools = [
  // ... existing tools
  myCustomTool
];
```

### Configuration

The system uses centralized configuration management:

- **Backend**: Environment variables in `.env` file
- **Frontend**: Configuration through `HostConfiguration.ts`
- **MCP Protocol**: Automatic capability negotiation
- **Runtime**: Dynamic configuration updates supported

### API Endpoints

- **POST /api/llm**: LLM proxy with OpenAI Chat Completions API
- **GET /api/health**: Health check and system status

## üîç Troubleshooting

### Common Issues

1. **"Failed to start agent"**
   - Check that backend is running on port 3001
   - Verify OpenAI API key is set in `backend/.env`
   - Check browser console for MCP initialization errors

2. **"No tools available"**
   - Ensure MCP server initialization completed successfully
   - Check JSON-RPC transport connectivity in debug panel
   - Verify tool registration in browser console

3. **"Tool execution failed"**
   - Check tool parameters match the expected schema
   - Review tool execution history in debug panel
   - Verify DOM elements exist for DOM query operations

### Debug Features

- **JSON-RPC Monitor**: Complete request/response logging with correlation IDs
- **MCP Debug Panel**: Real-time protocol communication monitoring
- **Tool Execution Logs**: Detailed tool execution history with timing
- **Health Dashboard**: System health monitoring with error tracking
- **Browser Console**: Comprehensive logging with MCP protocol details

## üöÄ Advanced Features

### Browser-Native MCP Advantages

#### **Performance Benefits**
- **Zero Network Latency**: In-memory JSON-RPC between MCP components
- **Shared Memory**: Efficient data sharing within browser context
- **Optimized Transport**: Custom transport layer for browser environment

#### **Security Benefits**
- **Sandboxed Environment**: Browser security model provides natural isolation
- **No External Processes**: All MCP components run in controlled environment
- **Direct DOM Access**: Tools can interact with page elements securely

#### **Development Benefits**
- **Unified Debugging**: All MCP components debuggable in browser dev tools
- **Hot Reloading**: Development changes reflected immediately
- **Rich Tooling**: Browser debugging and profiling capabilities

### MCP vs Traditional Tool Calling

| Aspect | Traditional Function Calling | MCP Implementation |
|--------|------------------------------|-------------------|
| **Architecture** | Direct LLM ‚Üî Functions | Host ‚Üî Client ‚Üî Server |
| **Protocol** | Vendor-specific formats | Standardized MCP protocol |
| **Capability Discovery** | Static tool definitions | Dynamic capability negotiation |
| **Security** | Function-level isolation | Component-level boundaries |
| **Extensibility** | Monolithic tool sets | Composable server ecosystem |
| **Context Management** | LLM manages all context | Host coordinates context |
| **Multi-Agent Support** | Limited sharing | Efficient resource sharing |
| **Debugging** | Basic logging | Comprehensive protocol monitoring |

### Future Enhancements

#### **Multi-Server Support**
```typescript
// Multiple MCP servers (future enhancement)
const fileServer = new FileMCPServer();
const apiServer = new APIMCPServer(); 
const dbServer = new DatabaseMCPServer();

// Host manages multiple client connections
host.addServer(fileServer);
host.addServer(apiServer);
host.addServer(dbServer);
```

#### **Advanced MCP Features**
- **Resource Subscriptions**: Real-time updates from MCP servers
- **Prompt Templates**: Reusable prompt templates from servers
- **Sampling**: Server-initiated LLM requests
- **Notifications**: Server-to-client event streaming
- **External Servers**: Connection to remote MCP servers

## üìä Performance Characteristics

### Execution Metrics
- **Tool Execution**: Sub-millisecond latency for most operations
- **JSON-RPC Overhead**: ~1-2ms for serialization/deserialization
- **Memory Usage**: Efficient shared infrastructure across agents
- **Conversation Trimming**: Automatic optimization to prevent memory bloat

### Scalability
- **Concurrent Agents**: Up to 5 agents with shared MCP infrastructure
- **Tool Registry**: Supports hundreds of registered tools
- **Execution History**: Configurable history limits with automatic cleanup
- **Real-time Monitoring**: Minimal performance impact from debug features

## üìÑ License

MIT License - see LICENSE file for details.

## üôè Acknowledgments

- **Model Context Protocol (MCP)** for the revolutionary standard specification
- **OpenAI** for LLM capabilities and Chat Completions API
- **React & Vite** for the modern frontend framework
- **Express.js** for the robust backend server
- **JSON-RPC 2.0** for the standardized communication protocol

---

This MCP implementation demonstrates how AI architectures can run entirely in the browser while maintaining protocol compliance. Start with the Quick Start guide above to get started.
